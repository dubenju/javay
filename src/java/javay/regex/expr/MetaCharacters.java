package javay.regex.expr;

import java.util.HashMap;
import java.util.Map;

public class MetaCharacters {
    private static final Map<String, String> mcs = new HashMap<String, String>();
    static {
        mcs.put("$", "匹配输入字符串的结束位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r' 之前的位置。要匹配 $ 字符本身，请使用 \\$。");
        mcs.put("(", "标记一个子表达式的开始。子表达式可以获取供以后使用。要匹配(字符，请使用 \\(。");
        mcs.put(")", "标记一个子表达式的结束。子表达式可以获取供以后使用。要匹配)字符，请使用 \\)。");
        mcs.put("*", "匹配前面的子表达式零次或多次。例如，zo* 能匹配 'z' 以及 'zoo'。* 等价于{0,}。要匹配 * 字符，请使用 \\*。");
        mcs.put("+", "匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 'zo' 以及 'zoo'，但不能匹配 'z'。+ 等价于 {1,}。要匹配 + 字符，请使用 \\+。");
        mcs.put(".", "匹配除换行符 '\\n' 之外的任何单个字符（也包括点字符自身）。要匹配包括 '\\n' 在内的任何字符，请使用象 '[.\\n]' or '(.|\\n)' 的模式。要匹配 .，请使用 \\.。");
        mcs.put("?", "匹配前面的子表达式零次或一次(例如，'do(es)?' 可以匹配 'do' 或 'does' 中的'do' 。? 等价于 {0,1}。)，或指明一个非贪婪限定符。当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 'oooo'，'o+?' 将匹配单个 'o'，而 'o+' 将匹配所有 'o'。要匹配 ? 字符，请使用 \\?。");
        mcs.put("[", "标记一个范围的开始。要匹配 [，请使用 \\[。");
        mcs.put("\\", "\\是一个元字符，将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如， 'n' 匹配字符 'n'。'\\n' 匹配一个换行符。序列 '\\' 匹配 '\\' 而 '\\(' 则匹配 '('。");
        mcs.put("]", "标记一个范围的结束。要匹配 ]，请使用 \\]。");
        mcs.put("^", "匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '\\n' 或 '\\r' 之后的位置。要匹配 ^ 字符本身，请使用 \\^。");
        mcs.put("{", "标记限定符表达式的开始。要匹配 {，请使用 \\{。");
        mcs.put("|", "指明两项之间的一个选择。要匹配 |，请使用 \\|。");
        mcs.put("}", "标记限定符表达式的结束。要匹配 }，请使用 \\}。");

        mcs.put("\\$", "匹配一个$字符。");
        mcs.put("\\(", "匹配一个(字符。");
        mcs.put("\\)", "匹配一个)字符。");
        mcs.put("\\*", "匹配一个*字符。");
        mcs.put("\\+", "匹配一个+字符。");
        mcs.put("\\.", "匹配一个点字符。");
        mcs.put("\\?", "匹配一个?字符。");
        mcs.put("\\B", "匹配非单词边界。'er\\B' 能匹配 'verb' 中的 'er'，但不能匹配 'never' 中的 'er'。");
        mcs.put("\\D", "匹配一个非数字字符。等价于 [^0-9]。");
        mcs.put("\\S", "匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。");
        mcs.put("\\W", "匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。");
        mcs.put("\\[", "匹配一个[字符。");
        mcs.put("\\\\", "匹配一个\\字符。");
        mcs.put("\\]", "匹配一个]字符。");
        mcs.put("\\^", "匹配一个^字符。");
        mcs.put("\\b", "匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配'never' 中的 'er'，但不能匹配 'verb' 中的 'er'。");
        mcs.put("\\d", "匹配一个数字字符。等价于 [0-9]。");
        mcs.put("\\f", "匹配一个换页符。等价于 \\x0c 和 \\cL。");
        mcs.put("\\n", "匹配一个换行符。等价于 \\x0a 和 \\cJ。");
        mcs.put("\\r", "匹配一个回车符。等价于 \\x0d 和 \\cM。");
        mcs.put("\\s", "匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。");
        mcs.put("\\t", "匹配一个制表符（Tab键）。等价于 \\x09 和 \\cI。");
        mcs.put("\\v", "匹配一个垂直制表符。等价于 \\x0b 和 \\cK。");
        mcs.put("\\w", "匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。");
        mcs.put("\\{", "匹配一个{字符。");
        mcs.put("\\|", "匹配一个|字符。");
        mcs.put("\\}", "匹配一个}字符。");
    }
    public static String getComment(String key) {
        return mcs.get(key);
    }
}

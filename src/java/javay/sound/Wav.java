package javay.sound;

/**
 * wav文件格式分析详解

一、综述
    WAVE文件作为多媒体中使用的声波文件格式之一，它是以RIFF格式为标准的。
RIFF是英文Resource Interchange File Format的缩写，每个WAVE文件的头四个
字节便是“RIFF”。
    WAVE文件是由若干个Chunk组成的。按照在文件中的出现位置包括：RIFF WAVE
Chunk, Format Chunk, Fact Chunk(可选), Data Chunk。具体见下图：

------------------------------------------------
|             RIFF WAVE Chunk                  |
|             ID  = 'RIFF'                     |
|             RiffType = 'WAVE'                |
------------------------------------------------
|             Format Chunk                     |
|             ID = 'fmt '                      |
------------------------------------------------
|             Fact Chunk(optional)             |
|             ID = 'fact'                      |
------------------------------------------------
|             Data Chunk                       |
|             ID = 'data'                      |
------------------------------------------------
            图1   Wav格式包含Chunk示例

    其中除了Fact Chunk外，其他三个Chunk是必须的。每个Chunk有各自的ID，位
于Chunk最开始位置，作为标示，而且均为4个字节。并且紧跟在ID后面的是Chunk大
小（去除ID和Size所占的字节数后剩下的其他字节数目），4个字节表示，低字节
表示数值低位，高字节表示数值高位。下面具体介绍各个Chunk内容。
PS：
    所有数值表示均为低字节表示低位，高字节表示高位。

二、具体介绍
RIFF WAVE Chunk
    ==================================
    |       |所占字节数|  具体内容   |
    ==================================
    | ID    |  4 Bytes |   'RIFF'    |
    ----------------------------------
    | Size  |  4 Bytes |             |
    ----------------------------------
    | Type  |  4 Bytes |   'WAVE'    |
    ----------------------------------
            图2  RIFF WAVE Chunk

    以'RIFF'作为标示，然后紧跟着为size字段，该size是整个wav文件大小减去ID
和Size所占用的字节数，即FileLen - 8 = Size。然后是Type字段，为'WAVE'，表
示是wav文件。
    结构定义如下：
 struct RIFF_HEADER
 {
  char szRiffID[4];  // 'R','I','F','F'
  DWORD dwRiffSize;
  char szRiffFormat[4]; // 'W','A','V','E'
 };

 

Format Chunk
    ====================================================================
    |               |   字节数  |              具体内容                   |
    ====================================================================
    | ID            |  4 Bytes  |   'fmt '                             |
    --------------------------------------------------------------------
    | Size          |  4 Bytes  | 数值为16或18，18则最后又附加信息           |
    --------------------------------------------------------------------  ----
    | FormatTag     |  2 Bytes  | 编码方式，一般为0x0001                   |     |
    --------------------------------------------------------------------     |
    | Channels      |  2 Bytes  | 声道数目，1--单声道；2--双声道            |     |
    --------------------------------------------------------------------     |
    | SamplesPerSec |  4 Bytes  | 采样频率                               |     |
    --------------------------------------------------------------------     |
    | AvgBytesPerSec|  4 Bytes  | 每秒所需字节数                          |     |===> WAVE_FORMAT
    --------------------------------------------------------------------     |
    | BlockAlign    |  2 Bytes  | 数据块对齐单位(每个采样需要的字节数)        |     |
    --------------------------------------------------------------------     |
    | BitsPerSample |  2 Bytes  | 每个采样需要的bit数                     |     |
    --------------------------------------------------------------------     |
    |               |  2 Bytes  | 附加信息（可选，通过Size来判断有无）        |     |
    --------------------------------------------------------------------  ----
                            图3  Format Chunk

    以'fmt '作为标示。一般情况下Size为16，此时最后附加信息没有；如果为18
则最后多了2个字节的附加信息。主要由一些软件制成的wav格式中含有该2个字节的
附加信息。
    结构定义如下：
 struct WAVE_FORMAT
 {
  WORD wFormatTag;
  WORD wChannels;
  DWORD dwSamplesPerSec;
  DWORD dwAvgBytesPerSec;
  WORD wBlockAlign;
  WORD wBitsPerSample;
 };
 struct FMT_BLOCK
 {
  char  szFmtID[4]; // 'f','m','t',' '
  DWORD  dwFmtSize;
  WAVE_FORMAT wavFormat;
 };


Fact Chunk
    ==================================
    |       |所占字节数|  具体内容   |
    ==================================
    | ID    |  4 Bytes |   'fact'    |
    ----------------------------------
    | Size  |  4 Bytes |   数值为4   |
    ----------------------------------
    | data  |  4 Bytes |             |
    ----------------------------------
            图4  Fact Chunk

    Fact Chunk是可选字段，一般当wav文件由某些软件转化而成，则包含该Chunk。
    结构定义如下：
 struct FACT_BLOCK
 {
  char  szFactID[4]; // 'f','a','c','t'
  DWORD  dwFactSize;
 };

 

Data Chunk
    ==================================
    |       |所占字节数|  具体内容   |
    ==================================
    | ID    |  4 Bytes |   'data'    |
    ----------------------------------
    | Size  |  4 Bytes |             |
    ----------------------------------
    | data  |          |             |
    ----------------------------------
             图5 Data Chunk

    Data Chunk是真正保存wav数据的地方，以'data'作为该Chunk的标示。然后是
数据的大小。紧接着就是wav数据。根据Format Chunk中的声道数以及采样bit数，
wav数据的bit位置可以分成以下几种形式：
    ---------------------------------------------------------------------
    |   单声道  |    取样1    |    取样2    |    取样3    |    取样4    |
    |          |--------------------------------------------------------
    |  8bit量化 |    声道0    |    声道0    |    声道0    |    声道0    |
    ---------------------------------------------------------------------
    |   双声道  |          取样1            |           取样2           |
    |          |--------------------------------------------------------
    |  8bit量化 |  声道0(左)  |  声道1(右)  |  声道0(左)  |  声道1(右)  |
    ---------------------------------------------------------------------
    |          |          取样1            |           取样2           |
    |   单声道  |--------------------------------------------------------
    | 16bit量化 |    声道0    |  声道0      |    声道0    |  声道0      |
    |          | (低位字节)  | (高位字节)  | (低位字节)  | (高位字节)  |
    ---------------------------------------------------------------------
    |          |                         取样1                         |
    |   双声道  |--------------------------------------------------------
    | 16bit量化 |  声道0(左)  |  声道0(左)  |  声道1(右)  |  声道1(右)  |
    |          | (低位字节)  | (高位字节)  | (低位字节)  | (高位字节)  |
    ---------------------------------------------------------------------
                         图6 wav数据bit位置安排方式

    Data Chunk头结构定义如下：
    struct DATA_BLOCK
 {
  char szDataID[4]; // 'd','a','t','a'
  DWORD dwDataSize;
 };


三、小结
    因此，根据上述结构定义以及格式介绍，很容易编写相应的wav格式解析代码。
这里具体的代码就不给出了。

 

四、参考资料
    1、李敏, 声频文件格式WAVE的转换, 电脑知识与技术(学术交流), 2005.
    2、http://www.codeguru.com/cpp/g-m/multimedia/audio/article.php/c8935__1/
    3、http://www.smth.org/pc/pcshowcom.php?cid=129276
    
    0x0000	unknown
    0x0001	PCM
    0x0002	MS ADPCM
    0x0005	IBM CSVD
    0x0006	A-Law
    0x0007	μ-Law
    0x0010	OKI ADPCM
    0x0011	IMA/DVI ADPCM
    0x0012	MediaSpace ADPCM
    0x0013	Sierra ADPCM
0x0014	ADPCM (G.723)
0x0015	DIGISTD
0x0016	DIGIFIX
0x0020	YAMAHA ADPCM
0x0021	SONARC
0x0022	TrueSpeech
0x0023	Echo Speech1
0x0024	AF36 (Audiofile)
0x0025	Apix
0x0026	AF10 (Audiofile)
0x0030	AC2 (Dolby)
0x0031	GSM 6.10
0x0033	ANTEX ADPCM
0x0034	VQLPC (Control Resources)
0x0035	DIGIREAL
0x0036	DIGIADPCM
0x0037	CR10 (Control Resources)
0x0040	ADPCM (G.721)
0x0101	IBM μ-LAW
0x0102	IBM A-LAW
0x0103	IBM ADPCM
0x0200	Creative Labs ADPCM
0x0300	FM TOWNS
0x1000	Olivetti GSM
0x1001	Olivetti ADPCM
0x1002	Olivetti CELP
0x1003	Olivetti SBC
0x1004	Olivetti OPR

データ読み出し手順の例

RIFFとWAVEをチェック
チャンクの種類とチャンクデータサイズをチェック
チャンクが "fmt " なら, フォーマット情報を読み込む
チャンクが "fact" なら, サンプル数を読み込む
チャンクが "data" なら, PCM データをブロック単位で読み込む

    
 * @author dubenju
 *
 */
public class Wav {

}
